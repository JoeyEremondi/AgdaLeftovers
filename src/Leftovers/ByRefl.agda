{-# OPTIONS --without-K #-}
module Leftovers.ByRefl where

open import Leftovers.Utils
open import Leftovers.Leftovers


import Level as Level
open import Reflection
open import Reflection.Term
open import Reflection.Pattern as P
open import Reflection.TypeChecking.Monad.Instances

open import Relation.Binary.PropositionalEquality hiding ([_])
open import Relation.Nullary


open import Data.Unit
open import Data.Nat as Nat hiding (_‚äì_)
open import Data.Bool
open import Data.Product
open import Data.List as List
open import Data.Char as Char
open import Data.String as String


import Data.List.Categorical
open Data.List.Categorical.TraversableM {m = Level.zero} tcMonad

--This file was adapted from https://github.com/alhassy/gentle-intro-to-reflection


macro
  by-refls : Name ‚Üí Term ‚Üí TC ‚ä§
  by-refls typeName hole -- thm-you-hope-is-provable-by-refls
    = do
      -- let Œ∑ = nom
      Œ¥ ‚Üê getDefinition typeName
      clauses ‚Üê mapM mk-cls (constructors Œ¥)
      holeType ‚Üê inferType hole
      -- declareDef (vArg Œ∑) holeType
      let retFun = pat-lam clauses []
      unify hole retFun
    where
      mk-cls : Name ‚Üí TC Clause
      mk-cls ctor =
         do
           pat <- fully-applied-pattern ctor
           return (clause [ vArg (con ctor pat) ] (con (quote refl) []))

‚â°-type-info : Term ‚Üí TC (Arg Term √ó Arg Term √ó Term √ó Term)
‚â°-type-info (def (quote _‚â°_) (ùìÅ ‚à∑ ùíØ ‚à∑ arg _ l ‚à∑ arg _ r ‚à∑ [])) = return (ùìÅ , ùíØ , l , r)
‚â°-type-info _ = typeError [ strErr "Term is not a ‚â°-type." ]

{- If we have ‚Äúf $ args‚Äù return ‚Äúf‚Äù. -}
$-head : Term ‚Üí Term
$-head (var v args) = var v []
$-head (con c args) = con c []
$-head (def f args) = def f []
$-head (pat-lam cs args) = pat-lam cs []
$-head t = t



import Agda.Builtin.Reflection as Builtin

_$-‚âü_ : Term ‚Üí Term ‚Üí Bool
con c args $-‚âü con c‚Ä≤ args‚Ä≤ = Builtin.primQNameEquality c c‚Ä≤
def f args $-‚âü def f‚Ä≤ args‚Ä≤ = Builtin.primQNameEquality f f‚Ä≤
var x args $-‚âü var x‚Ä≤ args‚Ä≤ = does (x Nat.‚âü x‚Ä≤)
_ $-‚âü _ = false

{- Only gets heads and as much common args, not anywhere deep. :'( -}
infix 5 _‚äì_
{-# TERMINATING #-} {- Fix this by adding fuel (con c args) ‚âî 1 + length args -}
_‚äì_ : Term ‚Üí Term ‚Üí Term
l ‚äì r with l $-‚âü r | l | r
...| false | x | y = unknown
...| true | var f args | var f‚Ä≤ args‚Ä≤ = var f (List.zipWith (Œª{ (arg i!! t) (arg j!! s) ‚Üí arg i!! (t ‚äì s) }) args args‚Ä≤)
...| true | con f args | con f‚Ä≤ args‚Ä≤ = con f (List.zipWith (Œª{ (arg i!! t) (arg j!! s) ‚Üí arg i!! (t ‚äì s) }) args args‚Ä≤)
...| true | def f args | def f‚Ä≤ args‚Ä≤ = def f (List.zipWith (Œª{ (arg i!! t) (arg j!! s) ‚Üí arg i!! (t ‚äì s) }) args args‚Ä≤)
...| true | ll | _ = ll {- Left biased; using ‚Äòunknown‚Äô does not ensure idempotence. -}

{- ‚Äòunknown‚Äô goes to a variable, a De Bruijn index -}
unknown-elim : ‚Ñï ‚Üí List (Arg Term) ‚Üí List (Arg Term)
unknown-elim n [] = []
unknown-elim n (arg i unknown ‚à∑ xs) = arg i (var n []) ‚à∑ unknown-elim (n + 1) xs
unknown-elim n (arg i (var x args) ‚à∑ xs) = arg i (var (n + suc x) args) ‚à∑ unknown-elim n xs
unknown-elim n (arg i x ‚à∑ xs)       = arg i x ‚à∑ unknown-elim n xs
{- Essentially we want: body(unknown·µ¢)  ‚áí  Œª _ ‚Üí body(var 0)
   However, now all ‚Äúvar 0‚Äù references in ‚Äúbody‚Äù refer to the wrong argument;
   they now refer to ‚Äúone more lambda away than before‚Äù. -}

unknown-count : List (Arg Term) ‚Üí ‚Ñï
unknown-count [] = 0
unknown-count (arg i unknown ‚à∑ xs) = 1 + unknown-count xs
unknown-count (arg i _ ‚à∑ xs) = unknown-count xs

unknown-Œª : ‚Ñï ‚Üí Term ‚Üí Term
unknown-Œª zero body = body
unknown-Œª (suc n) body = unknown-Œª n (Œªv "section" ‚Ü¶ body)

{- Replace ‚Äòunknown‚Äô with sections -}
patch : Term ‚Üí Term
patch it@(def f args) = unknown-Œª (unknown-count args) (def f (unknown-elim 0 args))
patch it@(var f args) = unknown-Œª (unknown-count args) (var f (unknown-elim 0 args))
patch it@(con f args) = unknown-Œª (unknown-count args) (con f (unknown-elim 0 args))
patch t = t


macro
  spine : Term ‚Üí Term ‚Üí TC ‚ä§
  spine p goal =
    do œÑ ‚Üê inferType p
       _ , _ , l , r ‚Üê ‚â°-type-info œÑ
       unify goal (patch (l ‚äì r))

macro
  applyEq : Term ‚Üí Term ‚Üí TC ‚ä§
  applyEq p hole =
    do
       œÑ ‚Üê inferType hole
       _ , _ , l , r ‚Üê ‚â°-type-info œÑ
       unify hole ((def (quote cong) (vArg (patch (l ‚äì r)) ‚à∑ vArg p ‚à∑ [])))

